# Binary Exploitation

## Buffers

### Buffer Overflow

#### Examples (Buffer Overflow)

1. Program allocates two variables, `input_data` and `safe_var`, on the heap. The `input_data` is initialized with "pico" and the `safe_var` with "bico." The goal is to modify the content of `safe_var`, which triggers the program to print the flag stored in a file. Below is the relevant function in the challenge.

    ```c
    void check_win() {
        if (strcmp(safe_var, "bico") != 0) {
            printf("\nYOU WIN\n");

            // Print flag
            char buf[FLAGSIZE_MAX];
            FILE *fd = fopen("flag.txt", "r");
            fgets(buf, FLAGSIZE_MAX, fd);
            printf("%s\n", buf);
            fflush(stdout);

            exit(0);
        } else {
            printf("Looks like everything is still secure!\n");
            printf("\nNo flag for you :(\n");
            fflush(stdout);
        }
    }
    ```

    To modify the content of `safe_var`, the `write_buffer()` function is used, which allows us to write input directly to `input_data`.

    ```c
    void write_buffer() {
        printf("Data for buffer: ");
        fflush(stdout);
        scanf("%s", input_data);
    }
    ```

    Since `scanf` lacks boundary checks, it can overflow the `input_data` buffer, allowing us to overwrite adjacent memory locations, including the `safe_var`.

    To determine the exact string length required to overwrite `safe_var`, analyze the memory layout using the program’s “print heap” function, which will reveal the heap addresses of `input_data` and `safe_var`.

    These addresses are in hexadecimal format, so to find the difference between them (i.e., the distance in bytes), use a simple subtraction:

    1. The address of `input_data` is `0x63c3882552b0`.
    2. The address of `safe_var` is `0x63c3882552d0`.

    Subtracting these two addresses:

    `0x63c3882552d0 - 0x63c3882552b0 = 0x20`

    String like “abcdef” doesn’t work because it only writes 6 bytes (which isn’t enough to overflow). To successfully overwrite `safe_var`, the string needs to be sufficiently long, at least 33 bytes.

    So, inputting a string of 33 characters or more will allow us to overwrite the “bico” in `safe_var` with something else, causing the `check_win()` function to print the flag.

## String formatting

### Increasing output length

`%114d` is a format specifier in `"Gr%114d_Cheese"`. When `printf` encounters `%114d`, it expects to print a number with a width of 114 characters. Since no number is provided, it can print some garbage data, inflating the count to 114 characters.

This format specifier increases the output length significantly, making the `count` large enough to satisfy the condition `if (count > 2 * BUFSIZE)`.

### Undefined Behavior

1. Format Specifiers: The string `"Cla%sic_Che%s%steak"` contains several `%` symbols, typically used by `printf` to insert specific data types. However, `%s` expects a string argument, so even if `%steak` is not valid, but `%s` still tries to process it. When `printf` processes `%s` without a corresponding string argument, it can access arbitrary memory or cause the program to crash. This might be what fulfills the condition for SpongeBob's "outrageous" order.
